
-----

### **1. Estructura de Carpeta Final:**

Esta es la estructura exacta que debes tener en tu proyecto. Cada carpeta debe contener un archivo `__init__.py` (incluso si est√° vac√≠o).

```
tu_proyecto/  <-- Esta es la carpeta ra√≠z de tu bot (lo que subes a GitHub/Railway)
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ requirements.txt      <-- (Contiene las librer√≠as que necesita tu bot)
‚îú‚îÄ‚îÄ state_management.py
|
‚îú‚îÄ‚îÄ canales/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py          <-- Archivo vac√≠o
‚îÇ   ‚îú‚îÄ‚îÄ go_viral.py          
‚îÇ   ‚îú‚îÄ‚îÄ logs.py              
‚îÇ   ‚îú‚îÄ‚îÄ faltas.py            
‚îÇ   ‚îú‚îÄ‚îÄ presentate.py        
‚îÇ   |
‚îÇ   ‚îú‚îÄ‚îÄ mensajes/            
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py      <-- Archivo vac√≠o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ go_viral.py      
‚îÇ   |
‚îÇ   ‚îî‚îÄ‚îÄ notificaciones/      
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py      <-- Archivo vac√≠o
‚îÇ       ‚îî‚îÄ‚îÄ go_viral.py      
```


-----

### **1. `main.py`** (Contenido COMPLETO)

```python
import os
import discord
from discord.ext import commands, tasks
from dotenv import load_dotenv
from canales.logs import registrar_log
from state_management import RedisState # Importar RedisState
import asyncio

# Cargar variables de entorno del archivo .env
load_dotenv()

# Obtener el token del bot y la ID del gremio/servidor desde las variables de entorno
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD_ID = int(os.getenv('GUILD_ID')) # Convertir a int la ID del gremio

# Configurar intents para el bot
# Necesitas los intents de mensajes y reacciones, y miembros (si aplicable)
intents = discord.Intents.default()
intents.message_content = True  # Necesario para acceder a message.content
intents.messages = True         # Necesario para eventos de mensajes
intents.reactions = True        # Necesario para eventos de reacciones
intents.members = True          # Necesario para la gesti√≥n de miembros y sus datos

# Inicializar el bot con un prefijo de comando y los intents
# Puedes cambiar el prefijo '!' a lo que quieras
bot = commands.Bot(command_prefix='!', intents=intents)

# Instancia de RedisState
redis_state = RedisState()

@bot.event
async def on_ready():
    print(f'üü¢Bot conectado como {bot.user} (ID: {bot.user.id}) y listo para funcionar..')
    print('------')

    # Cargar cogs despu√©s de que el bot est√© listo
    try:
        # Cargar el cog de Go Viral
        await bot.load_extension('canales.go_viral')
        # Llama a la funci√≥n on_ready espec√≠fica del cog GoViralCog
        go_viral_cog = bot.get_cog('GoViralCog')
        if go_viral_cog:
            await go_viral_cog.go_viral_on_ready()
        print('All cogs loaded.')
    except Exception as e:
        print(f'ERROR al cargar cogs: {e}')

@bot.event
async def on_disconnect():
    print("Bot desconectado.")
    # Puedes registrar este evento en los logs si es necesario
    try:
        # Pasa None para user y channel, ya que el bot est√° desconectado y no hay un contexto espec√≠fico.
        # Puedes ajustar c√≥mo quieres manejar esto o si quieres registrarlo en absoluto.
        # Aqu√≠, pasamos el objeto 'bot' (self.bot en un cog, aqu√≠ simplemente 'bot')
        await registrar_log("El bot se ha desconectado de Discord.", None, None, bot)
    except Exception as e:
        print(f"Error al intentar registrar log de desconexi√≥n: {e}")

# Iniciar el bot
try:
    bot.run(TOKEN)
except discord.LoginFailure:
    print("Error: El token del bot es inv√°lido. Por favor, verifica tu DISCORD_TOKEN en el archivo .env")
except Exception as e:
    print(f"Error inesperado al iniciar el bot: {e}")

```

-----

### **2. `config.py`** (Contenido COMPLETO)

```python
import os

# --- TOKEN Y GUILD ---
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')
GUILD_ID = int(os.getenv('GUILD_ID'))

# --- IDs de Canales ---
# ID del canal objetivo para la funci√≥n Go Viral (el canal donde se comparten los links)
CANAL_OBJETIVO = 1353824447131418676 

# ID del canal donde se registrar√°n las faltas
CANAL_FALTAS = 1388891883551326298 

# ID del canal donde se registrar√°n los logs del bot
CANAL_LOGS = 1388347584061374514

# Canal de presentacion para nuevos miembros
CANAL_PRESENTATE = 1346959710519038006 

# IDs de los canales mencionados en el mensaje de bienvenida para nuevos miembros
CANAL_GUIAS_ID = 1353825076516094003 
CANAL_NORMAS_GENERALES_ID = 1353821141017559103 
CANAL_VICTORIAS_ID = 1353823190874456085 
CANAL_ESTRATEGIAS_PROBADAS_ID = 1376741512796442664 
CANAL_ENTRENAMIENTO_ID = 1376209406114664559 

```

-----

### **3. `state_management.py`** (Contenido COMPLETO)

```python
import redis
import os
import discord # Importar discord para WebhookType
import json # Importar json para manejar datos de posts

class RedisState:
    def __init__(self):
        self.redis_client = self._get_redis_client()

    def _get_redis_client(self):
        redis_url = os.getenv('REDIS_URL')
        if not redis_url:
            raise ValueError("REDIS_URL no est√° configurada en las variables de entorno.")
        
        try:
            client = redis.from_url(redis_url, decode_responses=True)
            # Prueba la conexi√≥n
            client.ping()
            print("Conectado a Redis exitosamente.")
            return client
        except redis.exceptions.ConnectionError as e:
            print(f"Error al conectar a Redis: {e}")
            raise

    def get_last_post_time(self, user_id):
        """
        Obtiene la √∫ltima marca de tiempo de publicaci√≥n de un usuario.
        """
        last_time = self.redis_client.get(f"last_post_time:{user_id}")
        return float(last_time) if last_time else None

    def set_last_post_time(self, user_id, timestamp):
        """
        Establece la √∫ltima marca de tiempo de publicaci√≥n para un usuario.
        """
        self.redis_client.set(f"last_post_time:{user_id}", timestamp)

    def save_post(self, message_id, author_id, channel_id, content, author_name):
        """
        Guarda una publicaci√≥n en Redis y la a√±ade a la lista de posts recientes del canal.
        """
        post_data = {
            'message_id': str(message_id),
            'author_id': str(author_id),
            'channel_id': str(channel_id),
            'content': content,
            'timestamp': discord.utils.utcnow().timestamp(),
            'author_name': author_name # Guardar el nombre del autor
        }
        post_json = json.dumps(post_data)
        
        # Guardar post individualmente
        self.redis_client.set(f"post:{message_id}", post_json)
        
        # A√±adir a la lista de posts recientes del canal (limitado a los √∫ltimos 50 para no crecer indefinidamente)
        # Usamos LTRIM para mantener solo los √∫ltimos N elementos
        list_key = f"recent_posts:{channel_id}"
        self.redis_client.lpush(list_key, post_json)
        self.redis_client.ltrim(list_key, 0, 49) # Mantener solo los √∫ltimos 50 posts

    def get_recent_posts(self, channel_id):
        """
        Obtiene los posts recientes de un canal.
        """
        posts = self.redis_client.lrange(f"recent_posts:{channel_id}", 0, -1)
        return [json.loads(p) for p in posts]

    def save_reaction(self, user_id, message_id):
        """
        Marca que un usuario ha reaccionado a un mensaje con üî•.
        """
        self.redis_client.sadd(f"reacted_users:{message_id}", str(user_id))

    def has_reaction(self, user_id, message_id):
        """
        Verifica si un usuario ha reaccionado a un mensaje con üî•.
        """
        return self.redis_client.sismember(f"reacted_users:{message_id}", str(user_id))
    
    def get_posts_by_author(self, author_id, channel_id):
        """
        Obtiene las publicaciones de un autor espec√≠fico en un canal.
        """
        all_recent_posts = self.get_recent_posts(channel_id)
        return [p for p in all_recent_posts if str(p['author_id']) == str(author_id)]

    def get_required_reactions_details(self, author_id, channel_id):
        """
        Obtiene detalles de los posts de otros usuarios a los que el autor actual debe reaccionar.
        Excluye posts del propio autor.
        """
        # Obtenemos los 10 posts m√°s recientes del canal
        recent_posts = self.get_recent_posts(channel_id)
        
        # Filtramos para obtener solo los posts de otros usuarios, no los del autor_id actual
        # Y que el post haya sido publicado antes del post actual del autor (impl√≠cito por el orden de get_recent_posts)
        # y que el autor NO haya reaccionado ya
        
        required_reactions = []
        for post in recent_posts:
            if str(post['author_id']) != str(author_id) and not self.has_reaction(author_id, post['message_id']):
                # Construir una URL de salto para el mensaje si es posible
                guild_id = os.getenv('GUILD_ID') # Asumiendo que GUILD_ID est√° en tus variables de entorno
                if guild_id:
                    jump_url = f"https://discord.com/channels/{guild_id}/{post['channel_id']}/{post['message_id']}"
                else:
                    jump_url = "URL no disponible"

                required_reactions.append({
                    'message_id': post['message_id'],
                    'author_id': post['author_id'],
                    'author_name': post['author_name'],
                    'url': jump_url
                })
        # Devolver solo los √∫ltimos 2 posts a los que se debe reaccionar
        return required_reactions[:2]

    def set_welcome_message_id(self, message_id, channel_id):
        """
        Guarda el ID del mensaje de bienvenida activo en Redis.
        """
        self.redis_client.set(f"welcome_message_active:{channel_id}", str(message_id))

    def get_welcome_message_id(self, channel_id):
        """
        Obtiene el ID del mensaje de bienvenida activo de Redis.
        """
        message_id = self.redis_client.get(f"welcome_message_active:{channel_id}")
        return int(message_id) if message_id else None

    async def get_or_create_webhook(self, channel):
        webhook_key = f"webhook:{channel.id}"
        webhook_url = self.redis_client.get(webhook_key)

        if webhook_url:
            try:
                webhook = discord.Webhook.from_url(webhook_url, client=channel.guild.client) # Asegurarse de usar client del bot
                await webhook.fetch() # Intenta obtener para verificar si es v√°lido
                return webhook
            except (discord.NotFound, discord.HTTPException):
                print(f"Webhook en Redis para el canal {channel.name} no v√°lido o no encontrado. Creando uno nuevo...")
                self.redis_client.delete(webhook_key) # Eliminar webhook inv√°lido

        # Si no existe o no es v√°lido, crear uno nuevo
        new_webhook = await channel.create_webhook(name=f"{channel.name}-go-viral-bot")
        self.redis_client.set(webhook_key, new_webhook.url)
        print(f"Nuevo webhook creado para el canal {channel.name}")
        return new_webhook

```

-----

### **4. `canales/go_viral.py`** (Contenido COMPLETO)

```python
import discord
from discord.ext import commands
import re
import asyncio
import json 
from state_management import RedisState
from canales.logs import registrar_log 
from canales.faltas import registrar_falta, enviar_advertencia 
from config import CANAL_OBJETIVO

# Importar los textos de mensajes y notificaciones desde las nuevas rutas relativas
from .mensajes.go_viral import WELCOME_MESSAGE_TITLE, WELCOME_MESSAGE_IMAGE_URL, WELCOME_MESSAGE_TEXT, FIRST_POST_WELCOME_MESSAGE_TEXT
from .notificaciones.go_viral import (
    URL_INVALIDA, INTERVALO_NO_RESPETADO, REACCIONES_PENDIENTES_CHANNEL, 
    REACCIONES_PENDIENTES_DM, LINK_CORREGIDO_CHANNEL, NO_REACCION_THUMBS_UP, 
    REACCION_FIRE_PROPIA_PUBLICACION, REACCION_NO_PERMITIDA
)

class GoViralCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.redis_state = RedisState()

    async def go_viral_on_ready(self):
        print(f"L√≥gica on_ready de GoViralCog iniciada para el canal {CANAL_OBJETIVO}...")

        channel_go_viral = None
        try:
            channel_go_viral = await self.bot.fetch_channel(CANAL_OBJETIVO)
        except discord.NotFound:
            print(f"ERROR: El canal go-viral con la ID: {CANAL_OBJETIVO} no fue encontrado en Discord. Aseg√∫rate de que la ID es correcta y el bot est√° en el servidor.")
            return
        except discord.Forbidden:
            print(f"ERROR: No tengo permisos para acceder al canal go-viral con la ID: {CANAL_OBJETIVO}.")
            return
        except Exception as e:
            print(f"ERROR inesperado al buscar el canal go-viral: {e}")
            return

        if not channel_go_viral: 
            print(f"ERROR: No se pudo obtener el objeto del canal go-viral con la ID: {CANAL_OBJETIVO} despu√©s de intentar buscarlo.")
            return

        existing_welcome_message_id = self.redis_state.redis_client.get(f"welcome_message_active:{CANAL_OBJETIVO}")
        if existing_welcome_message_id:
            try:
                old_message = await channel_go_viral.fetch_message(int(existing_welcome_message_id))
                await old_message.delete()
                print(f"DEBUG: Mensaje de bienvenida antiguo (ID: {existing_welcome_message_id}) borrado.")
                await registrar_log("Mensaje de bienvenida antiguo borrado para actualizar", self.bot.user, channel_go_viral, self.bot)
            except discord.NotFound:
                print(f"DEBUG: Mensaje de bienvenida antiguo (ID: {existing_welcome_message_id}) no encontrado. Posiblemente ya borrado.")
                self.redis_state.redis_client.delete(f"welcome_message_active:{CANAL_OBJETIVO}")
            except discord.Forbidden:
                print(f"ERROR: No tengo permisos para borrar el mensaje de bienvenida antiguo en el canal '{channel_go_viral.name}'.")
            except Exception as e:
                print(f"ERROR al intentar borrar mensaje de bienvenida antiguo: {e}")
        else:
            print("DEBUG: No se encontr√≥ mensaje de bienvenida antiguo en Redis.")

        print(f"DEBUG: Enviando nuevo mensaje de bienvenida para el canal {CANAL_OBJETIVO}.")
        embed = discord.Embed(title=WELCOME_MESSAGE_TITLE, description=WELCOME_MESSAGE_TEXT, color=discord.Color.gold())
        embed.set_image(url=WELCOME_MESSAGE_IMAGE_URL)
        try:
            sent_message = await channel_go_viral.send(embed=embed)
            self.redis_state.set_welcome_message_id(sent_message.id, CANAL_OBJETIVO)
            print("Mensaje de bienvenida al canal go-viral enviado exitosamente desde GoViralCog.")
            await registrar_log("Mensaje de bienvenida enviado al canal go-viral", self.bot.user, channel_go_viral, self.bot)
        except discord.Forbidden:
            print(f"ERROR: No tengo permisos para enviar el embed en el canal '{channel_go_viral.name}'.")
        except Exception as e:
            print(f"ERROR al enviar el mensaje de bienvenida al canal '{channel_go_viral.name}': {e}")


    @commands.Cog.listener()
    async def on_message(self, message):
        if message.channel.id != CANAL_OBJETIVO or message.author.bot:
            await self.bot.process_commands(message)
            return

        redis_state = self.redis_state
        user_id_str = str(message.author.id)
        original_author = message.author 
        
        is_first_post_ever = not redis_state.redis_client.exists(f"user_first_post:{user_id_str}")

        # ------------------------------------------------------------------------------------------------
        # Validaci√≥n de formato de URL - ¬°AJUSTE CR√çTICO AQU√ç!
        url_pattern_strict = r'^https://x\.com/\w+/status/\d+$' # Para la validaci√≥n estricta
        url_pattern_base = r'(https://x\.com/\w+/status/\d+)' # Para extraer la URL base
        content = message.content.strip()
        corrected_url = None

        if not re.match(url_pattern_strict, content): # Si no cumple el formato estricto
            try:
                base_url_match = re.match(url_pattern_base, content)
                if base_url_match: # Si se encuentra el patr√≥n base
                    corrected_url = base_url_match.group(1)
                else: # Si no se encuentra ni el patr√≥n estricto ni el base
                    raise ValueError("URL no coincide con el patr√≥n base.") # Forzar el error para ir al except
            except (AttributeError, ValueError): # Capturamos si .group(1) falla en None o si forzamos ValueError
                await message.delete()
                await enviar_notificacion_temporal(message.channel, original_author, URL_INVALIDA)
                # Pasa self.bot para registrar_falta y registrar_log
                await registrar_falta(original_author, "URL inv√°lida", message.channel, self.bot) 
                await registrar_log("Mensaje eliminado: URL inv√°lida", original_author, message.channel, self.bot)
                return
        
        # ------------------------------------------------------------------------------------------------
        # Validaci√≥n de intervalo de publicaciones (esperar 2 v√°lidas de otros)
        last_post_time = redis_state.get_last_post_time(original_author.id)
        recent_posts_count_others = len([p for p in redis_state.get_recent_posts(CANAL_OBJETIVO) if str(p['author_id']) != user_id_str])

        if not is_first_post_ever:
            if last_post_time and recent_posts_count_others < 2:
                await message.delete()
                await enviar_notificacion_temporal(message.channel, original_author, INTERVALO_NO_RESPETADO)
                await registrar_falta(original_author, "Publicaci√≥n antes de intervalo permitido", message.channel, self.bot) 
                await registrar_log("Mensaje eliminado: Intervalo no respetado", original_author, message.channel, self.bot)
                return

        # ------------------------------------------------------------------------------------------------
        # Validaci√≥n de reacciones üî• en publicaciones previas
        if not is_first_post_ever:
            required_reactions_details = redis_state.get_required_reactions_details(original_author.id, CANAL_OBJETIVO)
            missing_reactions = []
            
            for post_data in required_reactions_details:
                if not redis_state.has_reaction(original_author.id, post_data['message_id']):
                    missing_reactions.append(post_data)

            if missing_reactions:
                await message.delete()
                
                missing_info_list = []
                for mr in missing_reactions:
                    missing_info_list.append(f"- **{mr['author_name']}**: <{mr['url']}>")

                missing_info_str = "\n".join(missing_info_list)

                channel_msg = REACCIONES_PENDIENTES_CHANNEL.format(missing_info_str=missing_info_str)
                dm_msg = REACCIONES_PENDIENTES_DM.format(channel_name=message.channel.name, missing_info_str=missing_info_str)

                await enviar_notificacion_temporal(message.channel, original_author, channel_msg, dm_msg)
                await registrar_falta(original_author, "Falta de reacciones üî• pendientes", message.channel, self.bot) 
                await registrar_log(f"Mensaje eliminado: Sin reacciones üî• pendientes. Faltantes: {missing_info_str}", original_author, message.channel, self.bot)
                return
        
        # ------------------------------------------------------------------------------------------------
        # Correcci√≥n de URL autom√°tica (usando Webhook para mantener el autor original)
        final_message_content = corrected_url if corrected_url else content
        final_message = None

        try:
            webhook = await self.redis_state.get_or_create_webhook(message.channel)
            await message.delete()
            
            webhook_message = await webhook.send(
                content=final_message_content,
                username=original_author.display_name,
                avatar_url=original_author.display_avatar.url,
                wait=True
            )
            
            if corrected_url:
                await enviar_notificacion_temporal(message.channel, original_author,
                    f"{original_author.mention} {LINK_CORREGIDO_CHANNEL}")
                await registrar_log(f"URL corregida (via webhook): {content} -> {corrected_url}", original_author, message.channel, self.bot)
            
            final_message = webhook_message 
            
        except discord.Forbidden:
            print(f"ERROR: No tengo permisos para gestionar webhooks o enviar via webhook en el canal '{message.channel.name}'.")
            final_message = await message.channel.send(f"{final_message_content} (Publicado por el bot debido a error de permisos/webhook)")
            if corrected_url:
                await enviar_notificacion_temporal(message.channel, original_author,
                    f"{original_author.mention} {LINK_CORREGIDO_CHANNEL} Fue republicado por el bot.")
                await registrar_log(f"URL corregida (fallback bot): {content} -> {corrected_url}", original_author, message.channel, self.bot)

        except Exception as e:
            print(f"ERROR al enviar mensaje via webhook o gestionar: {e}")
            final_message = await message.channel.send(f"{final_message_content} (Publicado por el bot debido a un error)")
            if corrected_url:
                await enviar_notificacion_temporal(message.channel, original_author,
                    f"{original_author.mention} {LINK_CORREGIDO_CHANNEL} Fue republicado por el bot debido a un error.")
                await registrar_log(f"URL corregida (fallback bot): {content} -> {corrected_url}", original_author, message.channel, self.bot)

        # ------------------------------------------------------------------------------------------------
        # Guardar publicaci√≥n en Redis
        self.redis_state.save_post(final_message.id, original_author.id, CANAL_OBJETIVO, final_message.content, original_author.name)
        await registrar_log("Nueva publicaci√≥n v√°lida registrada (pendiente de üëç)", original_author, final_message.channel, self.bot)

        # ------------------------------------------------------------------------------------------------
        # Mensaje de bienvenida para usuario nuevo
        if is_first_post_ever:
            self.redis_state.redis_client.set(f"user_first_post:{user_id_str}", "true") 
            
            personalized_welcome_content = FIRST_POST_WELCOME_MESSAGE_TEXT.format(user_mention=original_author.mention)
            try:
                first_post_welcome_message = await message.channel.send(personalized_welcome_content)
                print(f"DEBUG: Mensaje de bienvenida personalizado enviado a {original_author.name} (ID: {first_post_welcome_message.id})")
                await registrar_log(f"Mensaje de bienvenida personalizado enviado a usuario nuevo: {original_author.name}", self.bot.user, message.channel, self.bot)

                self.bot.loop.create_task(self.delete_message_after_delay(first_post_welcome_message, 3600)) 
            except discord.Forbidden:
                print(f"ERROR: No tengo permisos para enviar el mensaje de bienvenida personalizado en el canal '{message.channel.name}'.")
            except Exception as e:
                print(f"ERROR al enviar mensaje de bienvenida personalizado: {e}")

        # ------------------------------------------------------------------------------------------------
        # Esperar reacci√≥n üëç del autor
        def check_reaction(reaction, user_check):
            print(f"DEBUG REACTION CHECK: Reaction emoji: {str(reaction.emoji)}, User ID: {user_check.id} ({user_check.name}), Message ID: {reaction.message.id}")
            print(f"DEBUG REACTION CHECK: Expected original author ID: {original_author.id}, Expected final message ID: {final_message.id}")
            
            return user_check.id == original_author.id and str(reaction.emoji) == 'üëç' and reaction.message.id == final_message.id

        try:
            print(f"DEBUG: Esperando reacci√≥n üëç para mensaje {final_message.id} por {original_author.name}...")
            await self.bot.wait_for('reaction_add', timeout=120, check=check_reaction)
            
            print(f"Reacci√≥n üëç del autor detectada y validada para el mensaje {final_message.id}")
            await registrar_log(f"Reacci√≥n üëç del autor validada para el mensaje: {final_message.content}", original_author, final_message.channel, self.bot)
            
        except asyncio.TimeoutError:
            print(f"Timeout: No se detect√≥ reacci√≥n üëç para el mensaje {final_message.id}")
            await final_message.delete()
            await enviar_notificacion_temporal(final_message.channel, original_author, 
                f"{original_author.mention} {NO_REACCION_THUMBS_UP}")
            await registrar_falta(original_author, "Sin reacci√≥n üëç en 120 segundos", final_message.channel, self.bot) 
            await registrar_log("Mensaje eliminado: Sin reacci√≥n üëç", original_author, final_message.channel, self.bot)
            
        await self.bot.process_commands(message)

    async def delete_message_after_delay(self, message: discord.Message, delay_seconds: int):
        await asyncio.sleep(delay_seconds)
        try:
            await message.delete()
            print(f"Mensaje (ID: {message.id}) borrado despu√©s de {delay_seconds} segundos.")
        except discord.NotFound:
            print(f"DEBUG: Mensaje (ID: {message.id}) ya borrado o no encontrado.")
        except discord.Forbidden:
            print(f"ERROR: No tengo permisos para borrar el mensaje (ID: {message.id}).")
        except Exception as e:
            print(f"ERROR inesperado al borrar mensaje (ID: {message.id}): {e}")

    @commands.Cog.listener()
    async def on_reaction_add(self, reaction, user):
        if reaction.message.channel.id != CANAL_OBJETIVO or user.bot:
            return

        if str(reaction.emoji) not in ['üëç', 'üî•']:
            try:
                await reaction.remove(user)
                print(f"DEBUG: Reacci√≥n no permitida '{str(reaction.emoji)}' de {user.name} eliminada.")
            except discord.Forbidden:
                print(f"ERROR: No tengo permisos para eliminar la reacci√≥n no permitida de {user.name} (permisos).")
            
            channel_msg = f"{user.mention} {REACCION_NO_PERMITIDA}"
            await enviar_notificacion_temporal(reaction.message.channel, user, channel_msg)
            await registrar_log(f"Reacci√≥n no permitida eliminada: '{str(reaction.emoji)}' por {user.name} en mensaje {reaction.message.id}", user, reaction.message.channel, self.bot)
            return 

        original_author_id_of_message = None
        recent_posts_raw = self.redis_state.redis_client.lrange(f"recent_posts:{CANAL_OBJETIVO}", 0, -1)
        author_name_for_log = "Desconocido"

        for p_json in recent_posts_raw:
            post_data = json.loads(p_json)
            if str(post_data['message_id']) == str(reaction.message.id):
                original_author_id_of_message = int(post_data['author_id'])
                author_name_for_log = post_data['author_name']
                break

        if original_author_id_of_message is None:
            print(f"WARNING: No se encontr√≥ informaci√≥n del post {reaction.message.id} en Redis para la reacci√≥n de {user.name}.")
            pass 

        if str(reaction.emoji) == 'üî•':
            if original_author_id_of_message is not None and user.id == original_author_id_of_message:
                try:
                    await reaction.remove(user)
                    print(f"Reacci√≥n üî• de {user.name} en su propia publicaci√≥n (ID: {reaction.message.id}) eliminada.")
                except discord.Forbidden:
                    print(f"Error: No se pudo eliminar la reacci√≥n üî• de {user.name} (permisos).")
                await enviar_notificacion_temporal(reaction.message.channel, user,
                    f"{user.mention} {REACCION_FIRE_PROPIA_PUBLICACION}")
                await registrar_falta(user, "Reacci√≥n üî• en propia publicaci√≥n", reaction.message.channel, self.bot) 
                await registrar_log("Reacci√≥n eliminada: üî• en propia publicaci√≥n", user, reaction.message.channel, self.bot)
                return 

            elif original_author_id_of_message is not None and user.id != original_author_id_of_message:
                self.redis_state.save_reaction(user.id, reaction.message.id)
                print(f"Reacci√≥n üî• de {user.name} registrada para el mensaje {reaction.message.id}")
                target_message_url = reaction.message.jump_url if reaction.message.guild else "No URL (DM/Unknown)"
                await registrar_log(f"Usuario {user.name} reaccion√≥ con üî• al mensaje de {author_name_for_log} (ID: {reaction.message.id}): {target_message_url}", user, reaction.message.channel, self.bot)


async def setup(bot):
    await bot.add_cog(GoViralCog(bot))

async def enviar_notificacion_temporal(channel, user, channel_content, dm_content=None):
    msg = await channel.send(channel_content)
    await asyncio.sleep(15)
    try:
        await msg.delete()
    except discord.NotFound:
        print(f"DEBUG: Mensaje temporal (ID: {msg.id}) ya borrado o no encontrado.")
    except discord.Forbidden:
        print(f"ERROR: No tengo permisos para borrar el mensaje temporal (ID: {msg.id}).")
    except Exception as e:
        print(f"ERROR inesperado al borrar mensaje temporal (ID: {msg.id}): {e}")

    if dm_content is None: 
        dm_content = f"‚ö†Ô∏è **Notificaci√≥n de {channel.name}**: {channel_content.replace(user.mention, '').strip()}\n\n*Este es un mensaje autom√°tico del bot.*"

    try:
        if user.dm_channel is None:
            await user.create_dm()
        await user.send(dm_content)
        print(f"DEBUG: Notificaci√≥n enviada por DM a {user.name}.")
    except discord.Forbidden:
        print(f"Error: No se pudo enviar DM a {user.name}. Puede que tenga los DMs deshabilitados.")
    except Exception as e:
        print(f"Error inesperado al enviar DM a {user.name}: {e}")

```

-----

### **5. `canales/faltas.py`** (Contenido COMPLETO)

```python
import discord
from config import CANAL_FALTAS
from canales.logs import registrar_log # Importa la funci√≥n de logs

async def enviar_advertencia(user, reason, channel):
    """
    Env√≠a una advertencia al usuario por DM.
    """
    warning_message = f"üö® **Advertencia de {channel.guild.name}** üö®\n\n" \
                      f"Tu acci√≥n en el canal #{channel.name} ha resultado en una falta.\n" \
                      f"**Raz√≥n:** {reason}\n\n" \
                      f"Por favor, revisa las reglas del canal para evitar futuras faltas.\n\n" \
                      f"*Este es un mensaje autom√°tico del bot.*"
    try:
        if user.dm_channel is None:
            await user.create_dm()
        await user.send(warning_message)
        print(f"Advertencia enviada por DM a {user.name}.")
    except discord.Forbidden:
        print(f"Error: No se pudo enviar DM de advertencia a {user.name}. Puede que tenga los DMs deshabilitados.")
    except Exception as e:
        print(f"Error inesperado al enviar DM de advertencia a {user.name}: {e}")

async def registrar_falta(user, reason, channel, bot): 
    """
    Registra una falta para un usuario en el canal de faltas y notifica al usuario.
    """
    if not bot: # Si por alguna raz√≥n el bot no se pasa, es un error
        print("ERROR: Instancia del bot no proporcionada a registrar_falta.")
        return

    faltas_channel = bot.get_channel(CANAL_FALTAS) # Usar el objeto 'bot' pasado para obtener el canal
    
    if not faltas_channel:
        print(f"ERROR: No se encontr√≥ el canal de faltas con ID {CANAL_FALTAS}.")
        await registrar_log(f"ERROR: No se encontr√≥ el canal de faltas ID: {CANAL_FALTAS} para registrar falta de {user.name}.", user, channel, bot) 
        return

    falta_message = f"**Falta Registrada:** Usuario: {user.name} (ID: {user.id}) | Raz√≥n: {reason} | Canal: #{channel.name}"

    try:
        await faltas_channel.send(falta_message)
        print(f"Falta de {user.name} registrada en #{faltas_channel.name}: {reason}")
        await registrar_log(f"Falta registrada: {reason}", user, channel, bot) 
    except discord.Forbidden:
        print(f"ERROR: No tengo permisos para enviar mensajes en el canal de faltas '{faltas_channel.name}'.")
    except Exception as e:
        print(f"ERROR inesperado al registrar falta: {e}")
    
    await enviar_advertencia(user, reason, channel)

```

-----

### **6. `canales/logs.py`** (Contenido COMPLETO)

```python
import discord
from config import CANAL_LOGS

async def registrar_log(message_text, user, channel, bot_instance):
    """
    Registra un mensaje de log en el canal de logs del bot.
    :param message_text: El contenido del mensaje de log.
    :param user: El objeto de usuario asociado al log (puede ser None si no aplica).
    :param channel: El objeto de canal asociado al log (puede ser None si no aplica).
    :param bot_instance: La instancia del bot para obtener el canal de logs.
    """
    # Verificar si la instancia del bot est√° disponible
    if not bot_instance:
        print("ERROR: Instancia del bot no proporcionada a registrar_log. No se puede enviar el log a Discord.")
        print(f"Log sin enviar: {message_text}")
        return

    # Obtener el canal de logs usando la instancia del bot
    log_channel = bot_instance.get_channel(CANAL_LOGS)

    if not log_channel:
        print(f"ERROR: No se encontr√≥ el canal de logs con ID {CANAL_LOGS}. El mensaje '{message_text}' no pudo ser registrado en Discord.")
        return

    # Formatear el mensaje
    log_entry = f"[{discord.utils.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}] {message_text}"

    if user:
        log_entry += f" | Usuario: {user.name} (ID: {user.id})"
    if channel:
        log_entry += f" | Canal: #{channel.name} (ID: {channel.id})"

    try:
        await log_channel.send(log_entry)
    except discord.Forbidden:
        print(f"ERROR: No tengo permisos para enviar mensajes en el canal de logs '{log_channel.name}'.")
    except Exception as e:
        print(f"ERROR inesperado al enviar log a Discord: {e}")

```

-----

### **7. `canales/mensajes/go_viral.py`** (Contenido COMPLETO)

```python
# Titulo y cuerpo principal del mensaje de bienvenida
WELCOME_MESSAGE_TITLE = "¬°Bienvenido al canal GoViral!"
WELCOME_MESSAGE_IMAGE_URL = "https://i.imgur.com/kP8Sg3T.jpeg" # URL de tu imagen de bienvenida
WELCOME_MESSAGE_TEXT = (
    "üöÄ ¬°Prep√°rate para llevar tus posts al siguiente nivel y conseguir viralidad! "
    "Para comenzar, por favor lee atentamente las siguientes secciones:"
    "\n\n**üìö Gu√≠as y Recursos:** <#{CANAL_GUIAS_ID}>"
    "\n**üìú Normas Generales:** <#{CANAL_NORMAS_GENERALES_ID}>"
    "\n**üèÜ Victorias del d√≠a:** <#{CANAL_VICTORIAS_ID}>"
    "\n**üìä Estrategias Probadas:** <#{CANAL_ESTRATEGIAS_PROBADAS_ID}>"
    "\n**üèãÔ∏è‚Äç‚ôÇÔ∏è Entrenamiento Viral:** <#{CANAL_ENTRENAMIENTO_ID}>"
    "\n\n**¬°Mucha suerte en tu camino a la viralidad!**"
).format(
    CANAL_GUIAS_ID="1353825076516094003", # Ajusta esta ID a tu canal de gu√≠as
    CANAL_NORMAS_GENERALES_ID="1353821141017559103", # Ajusta esta ID
    CANAL_VICTORIAS_ID="1353823190874456085", # Ajusta esta ID
    CANAL_ESTRATEGIAS_PROBADAS_ID="1376741512796442664", # Ajusta esta ID
    CANAL_ENTRENAMIENTO_ID="1376209406114664559" # Ajusta esta ID
)

# Mensaje de bienvenida espec√≠fico para el primer post de un usuario
FIRST_POST_WELCOME_MESSAGE_TEXT = (
    "{user_mention}, ¬°Bienvenido a la comunidad GoViral! üéâ "
    "Este es tu primer post aqu√≠. Recuerda revisar las reglas y gu√≠as "
    "para que todos podamos crecer juntos. ¬°Mucha suerte!"
)

```

-----

### **8. `canales/notificaciones/go_viral.py`** (Contenido COMPLETO)

```python
# Mensajes de Notificaci√≥n del Canal Go Viral

# Notificaci√≥n cuando la URL es inv√°lida
URL_INVALIDA = (
    "Tu mensaje ha sido eliminado porque la URL no tiene el formato correcto de X.com (Twitter).\n"
    "Aseg√∫rate de que el enlace sea similar a `https://x.com/usuario/status/1234567890123456789`."
)

# Notificaci√≥n cuando no se respeta el intervalo de publicaciones
INTERVALO_NO_RESPETADO = (
    "Tu mensaje ha sido eliminado. Para poder publicar de nuevo, debes esperar "
    "a que otros dos usuarios publiquen un enlace en este canal DESPU√âS de tu √∫ltima publicaci√≥n."
)

# Notificaci√≥n cuando hay reacciones üî• pendientes en el canal
REACCIONES_PENDIENTES_CHANNEL = (
    "Tu mensaje ha sido eliminado. Debes reaccionar con üî• a las siguientes publicaciones de otros usuarios "
    "antes de poder publicar de nuevo:\n{missing_info_str}"
)

# Notificaci√≥n cuando hay reacciones üî• pendientes por DM
REACCIONES_PENDIENTES_DM = (
    "Tu post en el canal #{channel_name} fue eliminado.\n"
    "Tienes reacciones üî• pendientes en las siguientes publicaciones:\n{missing_info_str}\n"
    "¬°Reacciona para poder seguir publicando!"
)

# Notificaci√≥n cuando el link es corregido autom√°ticamente
LINK_CORREGIDO_CHANNEL = (
    "Tu enlace ha sido corregido autom√°ticamente para adaptarse al formato requerido.\n"
    "**Por favor, recuerda el formato correcto para futuras publicaciones.**"
)

# Notificaci√≥n cuando el usuario no reacciona con üëç a su propio post
NO_REACCION_THUMBS_UP = (
    "Tu publicaci√≥n ha sido eliminada porque no reaccionaste con üëç en el plazo de 120 segundos. "
    "Recuerda reaccionar a tu propio post para confirmar su validaci√≥n."
)

# Notificaci√≥n cuando el usuario reacciona üî• a su propia publicaci√≥n
REACCION_FIRE_PROPIA_PUBLICACION = (
    "¬°No puedes reaccionar con üî• a tu propia publicaci√≥n! Esa reacci√≥n es para apoyar a otros."
)

# Notificaci√≥n cuando se usa una reacci√≥n no permitida
REACCION_NO_PERMITIDA = (
    "Esa reacci√≥n no est√° permitida en este canal y ha sido eliminada."
)

```

-----

### **9. `.env`** (EJEMPLO - Aseg√∫rate que este est√© en la ra√≠z de tu proyecto y con tus valores REALES)

```
DISCORD_TOKEN=TU_TOKEN_DE_DISCORD_AQUI
REDIS_URL=redis://default:TU_CONTRASE√ëA_REDIS@HOST_REDIS:PUERTO_REDIS
GUILD_ID=TU_ID_DE_SERVIDOR_AQUI
```

-----

**Instrucciones Finales:**

1.  **Abre cada uno de los archivos listados arriba en tu editor de c√≥digo.**
2.  **Copia el contenido COMPLETO** de cada bloque de c√≥digo que te he proporcionado.
3.  **P√©galo reemplazando TODO el contenido** de tu archivo correspondiente.
4.  **Aseg√∫rate de que tus IDs en `config.py` y tu `.env` sigan siendo los correctos para tu servidor y tus credenciales.**
5.  **Guarda todos los archivos.**
6.  **Realiza un √∫ltimo despliegue en Railway.**

