import discord
from discord.ext import commands
import re
import asyncio
from state_management import RedisState
from canales.logs import registrar_log
from canales.faltas import registrar_falta, enviar_advertencia
from config import CANAL_OBJETIVO # CANAL_OBJETIVO es esencial aqu√≠

# Definimos una clase Cog para organizar las funciones del canal Go-Viral
class GoViralCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.redis_state = RedisState() # Instancia de RedisState

    # Este ser√° tu "on_ready" para este m√≥dulo, pero con un nombre diferente
    # para evitar conflictos y llamarlo expl√≠citamente desde main.py
    async def go_viral_on_ready(self):
        print(f"L√≥gica on_ready de GoViralCog iniciada para el canal {CANAL_OBJETIVO}...")

        # --- MODIFICACI√ìN TEMPORAL AQU√ç ---
        # Comenta la siguiente l√≠nea para forzar el env√≠o del mensaje de bienvenida
        # if not self.redis_state.is_welcome_message_active(CANAL_OBJETIVO):
        
        # Deja la siguiente l√≠nea sin comentar para que el c√≥digo dentro del if siempre se ejecute
        # Esto es solo para probar. Luego, ¬°recuerda descomentar la l√≠nea de arriba!
        if True: # <--- CAMBIA ESTO TEMPORALMENTE A 'if True:'
            print(f"DEBUG: Forzando el env√≠o del mensaje de bienvenida (Redis check bypass).") # Mensaje de depuraci√≥n
            channel_go_viral = self.bot.get_channel(CANAL_OBJETIVO)
            if channel_go_viral:
                welcome_message = """
# üßµ **REGLAS DEL CANAL GO-VIRAL** üßµ
## üéâ **¬°BIENVENIDOS A GO-VIRAL!** üéâ
¬°Nos alegra tenerte aqu√≠! Este es tu espacio para hacer crecer tu contenido de **ùïè (Twitter)** junto a nuestra incre√≠ble comunidad.
## üéØ **OBJETIVO**
Compartir contenido de calidad de **ùïè (Twitter)** siguiendo un sistema organizado de apoyo mutuo.
---
## üìã **REGLAS PRINCIPALES**
### üîó **1. FORMATO DE PUBLICACI√ìN**
‚úÖ **FORMATO CORRECTO:**
https://x.com/miguelrperaltaf/status/1931928250735026238
‚ùå **FORMATO INCORRECTO:**
https://x.com/miguelrperaltaf/status/1931928250735026238?s=46&t=m7qBPHFiZFqks3K1jSaVJg

**üìù NOTA:** El bot corregir√° autom√°ticamente los enlaces mal formateados, pero es mejor aprender el formato correcto.
### üëç **2. VALIDACI√ìN DE TU POST**
- Reacciona con **üëç** a tu propia publicaci√≥n
- **‚è±Ô∏è Tiempo l√≠mite:** 120 segundos
- Sin reacci√≥n = eliminaci√≥n autom√°tica
### üî• **3. APOYO A LA COMUNIDAD**
Antes de publicar nuevamente:
- Reacciona con **üî•** a TODAS las publicaciones posteriores a tuya
- **REQUISITO:** Apoya primero en **ùïè** con RT + LIKE + COMENTARIO
- Luego reacciona con üî• en Discord
### ‚è≥ **4. INTERVALO ENTRE PUBLICACIONES**
- Espera m√≠nimo **2 publicaciones v√°lidas** de otros usuarios
- No hay l√≠mite de tiempo, solo orden de turnos
---
## ‚ö†Ô∏è **SISTEMA DE FALTAS**
### üö® **Infracciones que generan falta:**
- Formato incorrecto de URL
- No reaccionar con üëç a tiempo
- Publicar sin haber apoyado posts anteriores
- Usar üî• en tu propia publicaci√≥n
- No respetar el intervalo de publicaciones
### üìä **Consecuencias:**
- Registro en canal de faltas
- Notificaci√≥n por DM
- Posibles sanciones seg√∫n historial
---
## ü§ñ **AUTOMATIZACI√ìN DEL BOT**
- ‚úÖ Correcci√≥n autom√°tica de URLs mal formateadas
- üóëÔ∏è Eliminaci√≥n de publicaciones inv√°lidas
- üì¨ Notificaciones temporales (15 segundos)
- üìù Registro completo en logs
- üí¨ Mensajes privados informativos
---
## üèÜ **CONSEJOS PARA EL √âXITO**
1. **Lee las reglas** antes de participar
2. **Apoya genuinamente** en ùïè antes de reaccionar
3. **Mant√©n el formato** exacto de URLs
4. **S√© constante** con las reacciones
5. **Respeta los turnos** de otros usuarios
---
## üìû **¬øDUDAS?**
Revisa el historial del canal o consulta en el canal soporte.
**¬°Juntos hacemos crecer nuestra comunidad! üöÄ**
---
*Bot actualizado ‚Ä¢ Sistema automatizado ‚Ä¢ Apoyo 24/7*
"""
                image_url = "https://drive.google.com/uc?export=download&id=1LGwse5dI_Q_PpQhhfpLBudteATKoy4Hj"
                embed = discord.Embed(title="üßµ REGLAS DEL CANAL GO-VIRAL üßµ", description=welcome_message, color=discord.Color.gold())
                embed.set_image(url=image_url)
                try:
                    sent_message = await channel_go_viral.send(embed=embed)
                    self.redis_state.set_welcome_message_id(sent_message.id, CANAL_OBJETIVO)
                    print("Mensaje de bienvenida al canal go-viral enviado exitosamente desde GoViralCog.")
                    await registrar_log("Mensaje de bienvenida enviado al canal go-viral", self.bot.user, channel_go_viral, self.bot)
                except discord.Forbidden:
                    print(f"ERROR: No tengo permisos para enviar el embed en el canal '{channel_go_viral.name}'.")
                except Exception as e:
                    print(f"ERROR al enviar el mensaje de bienvenida al canal '{channel_go_viral.name}': {e}")
            else:
                print(f"ERROR: No se pudo encontrar el canal go-viral con la ID: {CANAL_OBJETIVO}")
        # --- FIN DE LA MODIFICACI√ìN TEMPORAL ---
        else: # Este else se ejecutar√° si la l√≠nea comentada arriba no est√° comentada y Redis dice que ya est√° activo
            print(f"Mensaje de bienvenida ya activo para el canal {CANAL_OBJETIVO} seg√∫n Redis. No se env√≠a de nuevo.")


    # Ahora, tus eventos on_message y on_reaction_add se convierten en m√©todos de la Cog
    @commands.Cog.listener()
    async def on_message(self, message):
        if message.channel.id != CANAL_OBJETIVO or message.author.bot:
            await self.bot.process_commands(message)
            return

        redis_state = self.redis_state

        # Validar formato de la URL
        url_pattern = r'^https://x\.com/\w+/status/\d+$'
        content = message.content.strip()
        corrected_url = None
        if not re.match(url_pattern, content):
            try:
                base_url = re.match(r'(https://x\.com/\w+/status/\d+)', content).group(1)
                corrected_url = base_url
            except AttributeError:
                await message.delete()
                await enviar_notificacion_temporal(message.channel, message.author,
                    f"{message.author.mention} **Error:** La URL no es v√°lida. Usa el formato: `https://x.com/usuario/status/123456...`")
                await registrar_falta(message.author, "URL inv√°lida", message.channel)
                await registrar_log("Mensaje eliminado: URL inv√°lida", message.author, message.channel, self.bot)
                return

        # Verificar intervalo de publicaciones
        last_post = redis_state.get_last_post(message.author.id)
        recent_posts = redis_state.get_recent_posts(CANAL_OBJETIVO)
        if last_post and len([p for p in recent_posts if p['author_id'] != message.author.id]) < 2:
            await message.delete()
            await enviar_notificacion_temporal(message.channel, message.author,
                f"{message.author.mention} **Error:** Debes esperar al menos 2 publicaciones v√°lidas de otros usuarios antes de publicar nuevamente.")
            await registrar_falta(message.author, "Publicaci√≥n antes de intervalo permitido", message.channel)
            await registrar_log("Mensaje eliminado: Intervalo no respetado", message.author, message.channel, self.bot)
            return

        # Verificar reacciones üî• en publicaciones previas
        required_reactions = redis_state.get_required_reactions(message.author.id, CANAL_OBJETIVO)
        if not all(redis_state.has_reaction(message.author.id, post_id) for post_id in required_reactions):
            await message.delete()
            await enviar_notificacion_temporal(message.channel, message.author,
                f"{message.author.mention} **Error:** Debes reaccionar con üî• a todas las publicaciones posteriores a tu √∫ltima publicaci√≥n.")
            await registrar_falta(message.author, "Falta de reacciones üî•", message.channel)
            await registrar_log("Mensaje eliminado: Sin reacciones üî•", message.author, message.channel, self.bot)
            return

        # Corregir URL si es necesario
        if corrected_url:
            await message.delete()
            new_message = await message.channel.send(f"{corrected_url} (Corregido por el bot)")
            await registrar_log(f"URL corregida: {content} -> {corrected_url}", message.author, message.channel, self.bot)
            await enviar_notificacion_temporal(message.channel, message.author,
                f"{message.author.mention} **URL corregida:** Usa el formato `https://x.com/usuario/status/123456...` sin par√°metros adicionales.")
            message = new_message

        # Guardar publicaci√≥n en Redis
        redis_state.save_post(message.id, message.author.id, CANAL_OBJETIVO)
        await registrar_log("Nueva publicaci√≥n v√°lida registrada", message.author, message.channel, self.bot)

        # Esperar reacci√≥n üëç del autor
        def check_reaction(reaction, user_check):
            return user_check == message.author and str(reaction.emoji) == 'üëç' and reaction.message.id == message.id

        try:
            await self.bot.wait_for('reaction_add', timeout=120, check=check_reaction)
            print(f"Reacci√≥n üëç del autor detectada para el mensaje {message.id}")
        except asyncio.TimeoutError:
            await message.delete()
            await enviar_notificacion_temporal(message.channel, message.author,
                f"{message.author.mention} **Error:** No reaccionaste con üëç a tu publicaci√≥n en 120 segundos.")
            await registrar_falta(message.author, "Sin reacci√≥n üëç en 120 segundos", message.channel)
            await registrar_log("Mensaje eliminado: Sin reacci√≥n üëç", message.author, message.channel, self.bot)
            return

        await self.bot.process_commands(message)


    @commands.Cog.listener()
    async def on_reaction_add(self, reaction, user):
        if reaction.message.channel.id != CANAL_OBJETIVO or user.bot:
            return

        # Prohibir üî• en propia publicaci√≥n
        if str(reaction.emoji) == 'üî•' and user == reaction.message.author:
            try:
                await reaction.remove(user)
                print(f"Reacci√≥n üî• eliminada de la propia publicaci√≥n de {user.name}")
            except discord.Forbidden:
                print(f"Error: No se pudo eliminar la reacci√≥n üî• de {user.name} (permisos).")
            await enviar_notificacion_temporal(reaction.message.channel, user,
                f"{user.mention} **Error:** No puedes reaccionar con üî• a tu propia publicaci√≥n.")
            await registrar_falta(user, "Reacci√≥n üî• en propia publicaci√≥n", reaction.message.channel)
            await registrar_log("Reacci√≥n eliminada: üî• en propia publicaci√≥n", user, reaction.message.channel, self.bot)
            return

        # Registrar reacci√≥n üî• v√°lida
        if str(reaction.emoji) == 'üî•' and user != reaction.message.author:
            self.redis_state.save_reaction(user.id, reaction.message.id)
            print(f"Reacci√≥n üî• de {user.name} registrada para el mensaje {reaction.message.id}")


# La funci√≥n setup ahora a√±ade la Cog al bot
def setup(bot):
    bot.add_cog(GoViralCog(bot))

# Las funciones auxiliares pueden ir aqu√≠, ya que no son parte de la Cog directamente
# o podr√≠an ser m√©todos est√°ticos de la Cog si no necesitan 'self'
async def enviar_notificacion_temporal(channel, user, content):
    msg = await channel.send(content)
    await asyncio.sleep(15)
    await msg.delete()
    try:
        await user.send(f"‚ö†Ô∏è **Notificaci√≥n de {channel.name}**: {content.replace(user.mention, '')}\n\n*Este es un mensaje autom√°tico del bot.*")
    except discord.Forbidden:
        print(f"Error: No se pudo enviar DM a {user.name}. Puede que tenga los DMs deshabilitados.")
